# 웹 어플리케이션 구조
DBMS와 연동되는 웹 어플리케이션을 개발할 때 전형적으로 2가지의 구조로 구성할 수 있다.

* 서비스 - DAO로 구성
* 어플리케이션 - 도메인 - 영속성 영역으로 구성

## 1. 서비스 - DAO 구성
가장 많이 사용되는 구조이다.
```
Controller - Service - Dao
```

* Controller : 요청을 받아 서비스나 DAO에 넘기고 결과를 뷰에 뿌려주는 역할
* Service : 전달받은 요청을 DAO등을 통해 직접 구현한다. 비즈니스 로직이 존재
* Dao : 데이터베이스에 대한 CRUD접근 할 경우 모델과 함께 사용

> 스프링에서는 @Controller, @Service, @Repository, @Component 등으로 각 역할에 맞게 빈으로 등록한다. 이름은 다르지만 역할을 유사하다. 
> 등록한 빈들은 DI를 통해 서로 의존관계를 형성

### 1.1. DAO 인터페이스 정의
데이터베이스 테이블 단위로 생성하며 CRUD에 대한 메서드를 가진 인터페이스를 정의한다. 그리고 구현체 클래스를 정의하여 사용한다.

### 1.1.1 DAO 인터페이스 크기
테이블 당 1개의 인터페이스로 구현하는 것이 일반적. 조인을 하는 경우에는 어떻게 표현하는것이 좋을까?

1. 어플리케이션 조인 : 각 DAO에서 읽어와 코드 상에서 조인을 행하는 경우
2. 주 테이블에 해당하는 곳에 정의 : User, UserDetail이 있다면 User테이블에 메서드 정의
3. 조인을 위한 별도의 DAO정의

> 부트캠프 프로젝트를 진행했을때 이러한 고민을 한 적이 있다. 스키마를 설계하고 데이터를 가져오기 위해 조인 쿼리부터 짜고 코드는 결과를 모델에 넣어주는 방식이 먼저 떠올랐었는데, 조언을 듣고 어플리케이션 조인 방식으로 구현을 하였다.
> 
> 경험해본 결과, 쿼리를 작성하는 비용이 줄어들고, 좀 더 객체적(?)으로 생각하게 됐다. 데이터베이스 위주의 개발이 아닌 코드 중심의 개발이 되서 더 좋았다. 어느 한쪽만 사용하는 것이 아닌 상황에 따라 적절히 사용하는 것도 중요할 것이다.

### 1.2. 서비스 구현
서비스에서 해야할 것들을 인터페이스로 정의하고 서비스 구현체를 만들어 비즈니스 로직을 완성해나간다.

이미 정의해놓은 DAO를 통해 데이터를 CRUD하는 구간. 서비스 메서드는 _트랜잭션 단위_가 되므로 ```@Transactional``` 애노테이션 등으로 처리를 한다.

### 1.2.1. 서비스 크기
하나의 서비스를 정의하고 구현할 메서드를 어디까지 한 곳에서 정의해야하는지 고민을 할 때가 있다.

```java
public interface EmployeeService {
	public Long register(Employee emp);
	public int updateInfo(Employee emp);
	..
}
```

사원 관련된 기능들이 등록, 수정, 퇴직처리, 승진 등 많이 있을텐데 이를 위와 같이 한 서비스에 넣으면 _의존 객체 참조 개수 증가, 관련 없는 기능 들이 한 곳에 있으므로 복잡성이 증가_ 할 수 있다.

SRP(Single Responsibility Principle) 원칙으로 각각의 역할에 맞게 서비스를 분리하는 것이 좋다고 제안하고 있다. 이를 적용한다면 EmployeeService가 아닌 EmployeeRegistryService, RetirementService 등으로 쪼갤 수 있다.

### 1.2.2. 서비스 메서드의 파라미터 타입
보통 서비스의 메서드를 정의할 때 이미 정의한 모델 클래스를 받는 경우가 있다. 변경 요청을 위한 프로퍼티를 모델에 추가하는 것 보다는 RequestDto 와 같이 그 목적에 맞는 모델을 생성하는 것이 좋다.

Dto 클래스가 많아지지만 가독성을 높여주는 장점.
처리할 메서드의 필요한 데이터가 많아지면 _클래스_로 만들어서 넘겨준다. (Dto 객체)

## 2. 어플리케이션 - 도메인 - 영속성 구성
DDD(도메인 주도 개발) 중심의 구조

**구성요소**

* 도메인 영역
	* 엔티티 : 식별값과 도메인 로직
	* 리파지토리 : 엔티티 보관, 제공
* 영속성 영역
	* 리파지토리 구현 : 리파지토리 인터페이스 구현(JPA, Hibernate)
* 어플리케이션 영역
	* 어플리케이션 서비스

### 2.1. 도메인 구성
 * 도메인 모델 : 엔티티, 값 객체가 있다. 엔티티는 데이터 뿐만 아니라 기능을 함께 제공
 * 엔티티/객체 관리 : Repository는 엔티티의 생명주기를 관리
 
### 2.2. 영속성 구현
리파지토리의 구현영역으로 ORM기술을 많이 사용한다. JPA, Hibernate가 있는데 Spring Data JPA를 이용하면 상당히 간결해진다.

### 2.3. 어플리케이션 서비스 구현
클라이언트 요청을 받아 도메인 영역의 코드를 이용해서 처리하고 결과를 리턴한다.

* 도메인 영역의 리파지토리에서 엔티티 구하고
* 엔티티의 기능을 실행
* 결과를 리턴

위와 같은 구성으로 되어있다.
### 2.4. 컨트롤러와 뷰, 도메인 객체 접근
클라이언트는 두 종류의 기능을 서버에 요청

* 상태 변경 : 수정, 삭제, 추가
* 데이터 조회

회원정보 상세화면을 위한 컨트롤러 구현. 직접 회원정보를 읽어와 뷰에 전달하도록 구현하는데 

> 지연 로딩을 사용했을 때 주의점
>
> JPA에서 지연 로딩으로 1:1 연관필드를 가져올 때, 뷰에서 해당 필드를 사용할 경우 ```LazyInitializationException``` 예외가 발생한다.
>
> JPA 지연 로딩은 같은 트랜잭션 범위 내에서만 읽어올 수 있다.
> ```jsp
> 크기 : ${member.locker.size}
> ```
> 와 같이 뷰 코드는 _트랜잭션 범위 밖이므로 익셉션 발생_
>

이를 해결하고자 **OSIV 패턴**, **뷰에서 필요한 데이터를 트랜잭션 범위 내에서 로딩** 하는 방법 중 하나를 사용한다.

* OSIV(Open Session In View) 패턴 : 서블릿 필터를 이용해 웹 요청 시작 시 세선 시작, 처리가 끝나면 세션 종료하는 방식.
```OpenEntityManagerInViewFilter``` OSIV 필터를 이용해서 설정할 수 있다.
> 뷰 영역에서 도메인 객체의 상태를 변경할 수 있는 문제로 인해 선호하지 않는 경우도 있음

* 트랜잭션 범위 내에서 로딩 : 뷰에서 사용할 데이터를 미리 로딩한 뒤에 뷰에 전달. ```Hibernate.initialize()``` 를 이용하여 미리 로딩하는 방법


