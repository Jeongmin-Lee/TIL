# Function..
함수의 암묵적 전달인자.

객체의 메서드로 정의될 때, 함수의 암묵적 전달인자로 전달된다?


## 정의와 호출

* 전달인자의 제한이 없다. 명시된 전달인자보다 많으면 무시된다. 
* 명시된 전달인자를 적지않으면 undefined값이 할당됨
* 물론 위처럼 해서 정상작동 하는 경우가 있는 반면에, 아닌 경우도 있다. 

## 함수 리터럴
```js
function test(x) { ... } 
var test = function(x) { ... }
```
함수 리터럴을 이용하여 정의할 수도 있음.
이름을 붙이지 않아도 되는 익명 함수일 때 적합.


_선택적으로 함수 이름을 명명하는 것도 허용_ (Javascript 1.5 이전 버전은 제대로 동작 안할 수 있음)
익명 함수인데 재귀호출을 사용할 경우 쓰임.
```js
var test = function testScript(x) {...}
```


## 함수 전달인자
타입이 느슨한 언어라 데이터 타입을 미리 선언하는 것이 불가능. 가변적으로 전달인자를 받을 수 있다.

### 생략 가능한 전달인자
지정된 전달인자 개수보다 적은 수의 인자를 받으면 남은 것들은 `undefined`로 된다.

구현할 때 생략가능한 인자들의 위치를 끝에 넣는게 좋다. 
(function a(a, b) 일 때, a(1) 이라면 a는 절대 생략이 안됨, 하려면 명시적으로 null, undefined를)

### 가변길이 전달인자 목록(전달인자 객체 Arguments)
function 몸체에서 사용할 수 있는 `arguments` 객체
callee 프로퍼티

```js
function test(a,b) {
	if (arguments.length == 2) {
		...
	}
}
```

지정되지 않은 인자의 값도 `arguments[n]` 으로 접근할 수 있다.

_arguments 값을 변경하면 전달인자의 값도 변경된다_

`Arguments는 배열이 아닌 객체다`

#### callee 프로퍼티
현재 실행되고 있는 함수를 가리킨다.
거의 사용되지 않음.

_익명함수도 재귀적으로 자기자신을 호출할 수 있다_

```js
function(x) {
	if (x <= 1) return 1;
	return x * arguments.callee(x-1);
}
```

### 객체 프로퍼티를 전달인자로 사용하기
전달할 함수의 인자들이 많을 때 어떤 값을 어떤 순서로 넣어야하는지 기억하기 어려워진다. 이때 객체 리터럴로 정의하여 객체를 넘기는 방식으로 사용.

### 데이터로서의 함수
함수는 변수에 할당되거나 객체 프로퍼티와 배열 원소들에 저장될 수 있으며 함수의 전달인자로 사용할 수도 있다.

### 메서드로서의 함수
객체 프로퍼티로 함수를 정의할 수 있다.
호출된 메서드 내부에서 해당 객체를 `this` 키워드로 가리킬 수 있다.

```js
var calculator = {
	op1 : 1,
	op2 : 2,
	compute: function() {
		this.result = this.op1 + this.op2;
	}
}
```

`this` 키워드로 해당 메서드는 메서드가 속해있는 객체를 `암묵적 전달인자`로 건네받는다.

* 객체 내 메서드 프로퍼티에서 this : 해당 객체
* 함수로 호출했을 때의 this : 전역 객체


### 생성자 함수
new로 생성, this로 생성자 함수 호출

### 함수 프로퍼티와 메서드
함수를 `typeof` 하면 `function` 반환.
함수는 특수화된 종류의 객체. 그러므로 프로퍼티와 메서드가 있다.

#### length프로퍼티
`arguments.length` 는 전달 인자의 개수
함수 자체에서 length는 읽기전용이고 _함수에 정의된 매개변수의 개수 반환_

함수의 length는 함수 내외 모두 사용가능.

#### prototype프로퍼티
미리 정의된 prototype 객체를 가리키는 prototype프로퍼티가 있다.
함수가 new 생성자로 사용될 때 중요한 역할을 한다. 추후 설명


#### 나만의 함수 프로퍼티 정의
함수 호출 경계를 넘어서 존재가 유지되야하는 변수를 사용할 때,

전역 변수를 정의하여 사용하는 것 보다,
_function객체의 프로퍼티를 사용하는 것이 좋다_

```js
// 함수의 프로퍼티로 counter 선언. 코드 실행전에 함수가 처리되므로 가능
test.counter = 0;

function test() {
	return test.counter++;
}
```

#### apply(), call()
모든 함수에 대해 `apply(), call()` 메서드를 정의
함수가 마치 다른 객체에 있는 것처럼 호출할 수 있다.

```js
f.call(o, 1, 2);

o.m = f;
o.m(1,2);
delete o.m;
```

apply() 는 call과 유사하지만 함수로 건네줄 인자들이 배열이라는 점이 다르다.

```js
f.call(o, [1, 2]);
```

## 함수 유효범위와 클로저
기본적으로 자바스크립트는 `함수에 대한 유효범위 만 제공`. 
자바스크립트의 함수의 바디는 전역 유효 범위랑은 다른 `지역 유효 범위` 상에서 실행됨. 


### 어휘적 유효범위
함수는 동적이라기 보단 어휘적으로 유효 범위가 정해진다.

유효 범위 : 접근할 수 있는 범위를 의미

함수가 실행되는 유효범위가 아니라 정의되어있는 유효범위 안에서 실행됨.
정의될 때, 현재의 유효 범위 체인이 저장된다. 함수 내부 상태 중 일부가 됨.

함수 하나를 선언하면 함수에서 접근할 수 있는 유효범위는 함수를 포함한 객체의 모든 프로퍼티들(전역객체)이다.

함수 내에 중첩된 함수의 경우 이를 포함한 함수, 상위 객체들이 접근할 수 있는 유효범위가 된다. 

**유효범위체인이 고정되어도 유효 범위 체인 안에 정의된 프로퍼티는 변경될 수 있다.**

호출되는 시점에 연결된 모든 것들에 접근할 수 있다.

### 호출객체
`this`
arguments 프로퍼티로 초기화 된다.


### 네임스페이스로서의 호출 객체


### 클로저로서의 중첩된 함수
중첩된 함수를 허용, 함수를 데이터로 사용할 수 있으며 어휘적 유효 범위를 사용한다는 사실. -> 강력한 결과

```js
var a = xx;
..

function f() {

	function g() {
		...
	}
	g();
}

f();

```
* `f()` 호출 시 유효 범위 체인 : f() 호출객체 - 전역객체
* `g()` 호출 시 유효 범위 체인 : g() 호출객체 - f() 호출객체 - 전역객체

#### 클로저 예시
함수 호출의 경계를 넘어 값을 기억할 수 있는 함수가 필요할 때,
사라지지 않으면서도 private 속성을 지니는 변수를 생성할 수 있다.


## Function() 생성자
```js
var f = new Function("x", "y", "return x*y;");

==

function f(x, y) {return x*y;}
```

익명함수를 생성.

* 생성자를 사용하면 코드를 동적으로 생성하고 컴파일할 수 있다. `eval()`과 유사
* 호출될 때마다 파싱하고 새로운 함수 객체를 생성함. 
* 어휘적 유효범위를 사용하지 않는다. `최상위 레벨의 함수`인 것처럼 컴파일된다.
